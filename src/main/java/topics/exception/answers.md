### 1. Какова иерархия исключений.
**Throwable** - это базовый класс для всех ошибок и исключений. Он имеет два подкласса **Error** и **Exception**.

Класс **Error** представляет ошибки, которые обычно являются системными и фатальными. Эти ошибки, как правило, не могут быть обработаны в программе, и обычно они сигнализируют о серьезных проблемах с виртуальной машиной Java (JVM) или с операционной системой. Например, ошибки такие как OutOfMemoryError или StackOverflowError.

Класс **Exception** — это базовый класс для всех исключений, которые можно перехватывать и обрабатывать. Исключения делятся на два типа: проверяемые (checked) и непроверяемые (unchecked).
* **Проверяемые исключения** — это исключения, которые являются подклассами класса Exception, но не являются подклассами RuntimeException. Такие исключения обязательно должны быть обработаны либо с помощью конструкции try-catch, либо с использованием ключевого слова throws в методах. Пример проверяемого исключения IOException (ошибки ввода-вывода).

      try {
          // Код, который может вызвать IOException
      } catch (IOException e) {
          // Обработка исключения
      }

* **Непроверяемые исключения** — это исключения, которые являются подклассами RuntimeException. Эти исключения не требуют обязательной обработки, то есть их можно не обрабатывать в блоке try-catch, и не нужно указывать в throws. Обычно такие исключения возникают из-за ошибок в логике программы. Примеры непроверяемых исключений NullPointerException (обращение к null), ArrayIndexOutOfBoundsException (выход за пределы массива), ArithmeticException (например, деление на ноль)

      int result = 10 / 0; // Может вызвать ArithmeticException

### 2. Дайте определение понятию “исключение”.
Исключение в Java — это особая ситуация, возникающая во время выполнения программы, которая нарушает её нормальный ход работы. Исключения представляют собой объекты, которые создаются и выбрасываются (throw) при возникновении ошибок, а затем могут быть обработаны с помощью механизма обработки исключений (try-catch-finally).

### 3. Какая конструкция используется в Java для обработки исключений?
В Java для обработки исключений используется конструкция **try-catch-finally**, которая позволяет перехватывать и обрабатывать ошибки во время выполнения программы.

    try {
        // Код, который может вызвать исключение
    } catch (ExceptionType1 e1) {
        // Обработка исключения типа ExceptionType1
    } catch (ExceptionType2 e2) {
        // Обработка исключения типа ExceptionType2
    } finally {
        // Код, который выполнится в любом случае (необязательно)
    }

* try — содержит код, в котором может возникнуть исключение.
* catch — перехватывает и обрабатывает исключение. Можно использовать несколько блоков catch для разных типов исключений.
* finally (необязательный блок) — содержит код, который выполняется всегда, независимо от того, возникло исключение или нет (например, закрытие ресурсов).

Пример:

    try {
        int result = 10 / 0; // Деление на ноль вызовет ArithmeticException
    } catch (ArithmeticException e) {
        System.out.println("Ошибка: Деление на ноль!");
    } finally {
        System.out.println("Этот код выполнится в любом случае.");
    }
### 4. Можно/нужно ли обрабатывать ошибки jvm?

1. Типы ошибок JVM:
Error и его подклассы (например, VirtualMachineError) представляют критические проблемы, которые приложение не должно пытаться обрабатывать программно.
Примеры:
* **OutOfMemoryError**: закончилась память в куче.
* **StackOverflowError**: переполнение стека вызовов.
* **NoClassDefFoundError**: класс не найден на этапе выполнения.

2. Почему не нужно обрабатывать ошибки JVM?
Непредсказуемость: Эти ошибки возникают из-за проблем, которые приложение не может контролировать (например, нехватка памяти, ошибки JVM).
Невозможность восстановления: После таких ошибок состояние JVM может стать нестабильным, и продолжение работы приложения небезопасно.
Рекомендация Oracle: Официальная документация Java не рекомендует перехватывать Error (кроме крайних случаев).

3. Как реагировать на ошибки JVM?
   Не перехватывайте Error в коде:
```java
// ❌ Плохая практика:
try {
// код, который может вызвать ошибку
} catch (OutOfMemoryError e) {
// попытка "исправить" ошибку
}
```
Логируйте и завершайте работу: Если ошибка произошла, лучше залогировать её и корректно завершить приложение:
```java
java
Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
if (throwable instanceof VirtualMachineError) {
System.err.println("Критическая ошибка JVM: " + throwable);
// Логирование в файл, отправка уведомления и т.д.
System.exit(1); // Аварийное завершение
}
});
```
4. Когда можно обрабатывать Error?
Исключительные случаи (очень редко!):
Работа с нативным кодом (через JNI), где возможны специфические ошибки.
Очистка ресурсов перед завершением (например, закрытие файлов).
Пример:
```java
try {
// Код, вызывающий нативный метод
} catch (UnsatisfiedLinkError e) { // Подкласс Error
System.err.println("Нативная библиотека не найдена: " + e.getMessage());
// Попытка использовать резервный код
}
```
5. Профилактика вместо обработки:
Управляйте памятью: Избегайте утечек, настраивайте размеры куч (-Xmx, -Xms).
Контролируйте рекурсию: Преобразуйте рекурсивные алгоритмы в итеративные.
Проверяйте зависимости: Убедитесь, что все классы и библиотеки доступны.
6. Итог:
Ошибки JVM (Error) не обрабатывайте через try-catch, если нет веской причины.
Логируйте и завершайтесь при их возникновении.
Уделяйте внимание предотвращению таких ошибок на этапе разработки и настройки среды выполнения.
### 5. Какие существуют способы обработки исключений?

#### 1. **Блок try-catch**

   Описание: Перехват исключений в блоке try и их обработка в catch.\
   Пример:

```java
try {
int result = 10 / 0; // ArithmeticException
} catch (ArithmeticException e) {
System.out.println("Деление на ноль: " + e.getMessage());
}
```
Плюсы:
* Точечная обработка конкретных исключений.
* Возможность восстановления после ошибки.

#### 2. Блок finally

   Описание: Выполняется всегда, даже если возникло исключение.\
   Пример (закрытие ресурса):
```java
FileReader reader = null;
try {
reader = new FileReader("file.txt");
} catch (FileNotFoundException e) {
System.out.println("Файл не найден");
} finally {
if (reader != null) {
try {
reader.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
Плюсы:\
Гарантированное освобождение ресурсов (файлы, сетевые соединения).

#### **3. Try-with-resources (Java 7+)**
   Описание: Автоматическое закрытие ресурсов, реализующих интерфейс AutoCloseable.\
   Пример:

```java
try (FileReader reader = new FileReader("file.txt");
BufferedReader br = new BufferedReader(reader)) {
// Чтение файла
} catch (IOException e) {
System.out.println("Ошибка при работе с файлом: " + e.getMessage());
}
```
Плюсы:\
Упрощает код, избавляя от необходимости блока finally.

#### 4. Проброс исключений (throws)
   Описание: Передача исключения на уровень выше для обработки.\
   Пример:
```java
public void readFile() throws IOException {
FileReader reader = new FileReader("file.txt");
}
```
Когда использовать:\
* Если текущий метод не может обработать исключение.
* Для проверяемых исключений (checked exceptions).

#### 5. Создание пользовательских исключений

Описание: Определение собственных классов исключений.\
Пример:

```java
// Пользовательское исключение
class InvalidAgeException extends Exception {
public InvalidAgeException(String message) {
super(message);
}
}
// Использование
try {
if (age < 0) throw new InvalidAgeException("Возраст не может быть отрицательным");
} catch (InvalidAgeException e) {
System.out.println(e.getMessage());
}
```
Плюсы:\
Улучшает читаемость и логику приложения.

#### 6. Множественные блоки catch

   Описание: Обработка разных типов исключений отдельно.\
   Пример:
```java
try {
int[] arr = new int[5];
arr[10] = 42; // ArrayIndexOutOfBoundsException
} catch (ArithmeticException e) {
System.out.println("Арифметическая ошибка");
} catch (ArrayIndexOutOfBoundsException e) {
System.out.println("Выход за границы массива");
} catch (Exception e) {
System.out.println("Общее исключение: " + e);
}
```
Важно:\
Блоки catch должны идти от частных к общим типам исключений.

#### 7. Мульти-catch (Java 7+)
Описание: Обработка нескольких типов исключений в одном блоке.\
Пример:

```java
try {
// Код, который может вызвать разные исключения
} catch (ArithmeticException | NullPointerException e) {
System.out.println("Ошибка: " + e.getClass().getSimpleName());
}
```
Плюсы:
Уменьшает дублирование кода.

#### 8. Обработка исключений в потоках
   Описание: Использование UncaughtExceptionHandler для перехвата исключений в потоках.\
   Пример:

```java
Thread thread = new Thread(() -> {
throw new RuntimeException("Исключение в потоке");
});

thread.setUncaughtExceptionHandler((t, e) -> {
System.out.println("Исключение в потоке " + t.getName() + ": " + e.getMessage());
});

thread.start();
```
Плюсы:\
Предотвращает аварийное завершение приложения из-за исключений в дочерних потоках.

#### 9. Логирование исключений

   Описание: Запись информации об исключении в лог (например, через SLF4J, Log4j).\
   Пример:

```java
try {
// Код с исключением
} catch (Exception e) {
logger.error("Произошла ошибка: ", e);
}
```
Плюсы:\
Упрощает диагностику проблем в продакшене.

#### 10. Использование Optional (для избежания NPE)

Описание: Возврат Optional вместо null для предотвращения NullPointerException.\
Пример:

```java
public Optional<String> findNameById(int id) {
// Возвращает Optional.empty() вместо null
return Optional.ofNullable(database.getName(id));
}

// Использование
Optional<String> name = findNameById(42);
if (name.isPresent()) {
System.out.println(name.get());
}
```

### 6.  О чем говорит ключевое слово throws?

#### Ключевое слово throws:
**throws** используется в сигнатуре метода, чтобы указать, что метод может выбросить исключение (или несколько исключений) в процессе своей работы. Это предупреждение для вызывающего кода о том, что нужно обработать эти исключения или также объявить их через throws.
Указывает на возможные исключения, которые метод может выбросить.\
Обязательно для проверяемых исключений, если они не обрабатываются внутри метода.
Требует обработки вызывающим кодом через try-catch или проброс дальше через throws.

Непроверяемые исключения (unchecked):
Исключения, унаследованные от RuntimeException (например, NullPointerException, ArrayIndexOutOfBoundsException) или Error, не требуют объявления через throws. Их можно указывать, но это не обязательно.

#### Отличие от throw:
throws — объявляет возможные исключения в сигнатуре метода.
throw — непосредственно выбрасывает исключение в коде:
```java
public void validate(int age) throws IllegalArgumentException {
if (age < 0) {
throw new IllegalArgumentException("Возраст не может быть отрицательным");
}
}
```
### 17. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?
Блок finally выполняется всегда, независимо от того, было ли исключение. Если в блоке finally есть return, он переопределяет возвращаемое значение из блока catch или try.

### 18. Что вы знаете о OutOfMemoryError, SQLException? К какому типу checked или unchecked оно относится, почему?
OutOfMemoryError — это ошибка, которая возникает, когда виртуальная машина Java (JVM) не может выделить достаточно памяти для выполнения операции. Это может произойти, например, при создании большого количества объектов или при попытке загрузить слишком большой файл в память.

OutOfMemoryError относится к unchecked исключениям (непроверяемым).

SQLException — это исключение, которое возникает при работе с базами данных через JDBC (Java Database Connectivity). Оно может быть вызвано различными проблемами, такими как:

- Неправильный SQL-запрос.

- Проблемы с подключением к базе данных.

- Нарушение ограничений базы данных (например, уникальности или внешних ключей).

SQLException относится к checked исключениям (проверяемым).

### 19. Error? В каком случае используется Error. пример Error’а.
Error — это подкласс Throwable, который указывает на серьезные проблемы, с которыми приложение не должно пытаться справиться. Эти проблемы обычно связаны с внутренними сбоями в работе JVM (Java Virtual Machine) или системными ресурсами, и они не могут быть обработаны на уровне приложения.

Error используется для обозначения ситуаций, которые:

- Не могут быть обработаны приложением.

- Не должны быть перехвачены (хотя технически это возможно).

- Указывают на критические сбои, такие как:

  - Недостаток памяти (OutOfMemoryError).

  - Переполнение стека (StackOverflowError).

  - Ошибки загрузки классов (NoClassDefFoundError).

Пример Error:

* OutOfMemoryError
Возникает, когда JVM не может выделить достаточно памяти для создания нового объекта.

        public class Main {
            public static void main(String[] args) {
                try {
                // Попытка создать огромный массив
                   int[] array = new int[Integer.MAX_VALUE];
                } catch (OutOfMemoryError e) {
                   System.out.println("Поймана ошибка: " + e.getMessage());
                }
            }
        }

[← Вернуться к вопросам](README.md)

### 10. Что вы знаете об checked/unchecked исключениях?
В Java исключения являются способом обработки ошибок и необычных ситуаций, которые могут возникнуть во время выполнения программы. Исключения делятся на две основные категории: checked (проверяемые) и unchecked (непроверяемые). Различие между ними заключается в том, как компилятор Java обра-батывает их и какие требования предъявляются к коду, который может их выбросить.
1. Checked Exceptions (Проверяемые исключения):
•	Наследование: Checked exceptions — это подклассы клас-са java.lang.Exception, но не подклассы java.lang.RuntimeException.
•	Обязательная обработка: Ключевая особенность checked exceptions заключа-ется в том, что компилятор Java требует, чтобы код, который может выбросить checked exception, был обработан одним из двух способов:
•	Обработка с помощью try-catch: Код, который может выбросить ис-ключение, должен быть заключен в блок try-catch, где исключение пере-хватывается и обрабатывается.
•	Объявление в сигнатуре метода с помощью throws: Метод, который может выбросить checked exception, должен объявить это в своей сигнату-ре с помощью ключевого слова throws. Это говорит вызывающему мето-ду, что он тоже должен либо обработать исключение, либо объявить его в своей сигнатуре.
•	Примеры: IOException, SQLException, ClassNotFoundException
•	Предназначение: Checked exceptions используются для обозначения ошибок, которые предположительно могут произойти во время нормальной работы про-граммы и которые вызывающий код должен быть готов обработать. Например, попытка открыть файл, который не существует (FileNotFoundException), или по-пытка подключиться к базе данных, которая недоступна (SQLException).
•	Зачем это нужно?: Checked exceptions помогают обеспечить надежность про-граммы, заставляя разработчиков явно учитывать возможность возникновения определенных ошибок и принимать меры для их обработки.
Пример Checked Exception:
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class CheckedExceptionExample {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("nonexistent_file.txt"); // Может выбросить FileNotFoundException
            fis.read(); // Может выбросить IOException
        } catch (FileNotFoundException e) {
            System.err.println("Файл не найден: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("Ошибка ввода/вывода: " + e.getMessage());
        }
    }
}
В этом примере, если мы не обернем вызов FileInputStream и fis.read() в блоки try-catch, компилятор выдаст ошибку, потому что FileNotFoundException и IOException являются checked exceptions. Мы обязаны их обработать. 
2. Unchecked Exceptions (Непроверяемые исключения):
•	Наследование: Unchecked exceptions — это подклассы клас-са java.lang.RuntimeException или java.lang.Error.
•	Необязательная обработка: Компилятор Java не требует, чтобы код, кото-рый может выбросить unchecked exception, был обработан или объявлен в сигна-туре метода.
•	Примеры: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException, ArithmeticException (деление на ноль), OutOfMemoryError, StackOverflowError.
•	Предназначение: Unchecked exceptions используются для обозначения ошибок программирования, ошибок использования API, или серьезных системных оши-бок, которые обычно нельзя разумно восстановить во время выполнения. Счи-тается, что эти ошибки должны быть исправлены в коде, а не обрабатываться во время выполнения.
•	Зачем это нужно?: Требование обрабатывать все unchecked exceptions услож-нило бы код без особой пользы, так как они часто являются следствием фунда-ментальных ошибок. Считается, что разработчик должен избегать этих ошибок в первую очередь.
Пример Unchecked Exception:
public class UncheckedExceptionExample {
    public static void main(String[] args) {
        String str = null;
        try {
            int length = str.length(); // Может выбросить NullPointerException
            System.out.println("Длина строки: " + length);
        } catch (NullPointerException e) {
            System.err.println("Попытка обратиться к null: " + e.getMessage());
        }

        int[] arr = new int[5];
        try {
           int value = arr[10]; // Может выбросить ArrayIndexOutOfBoundsExcep-tion
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println("Выход за границы массива");
        }
    }
}

В этом примере NullPointerException и ArrayIndexOutOfBoundsException являются un-checked exceptions. Компилятор не заставляет нас оборачивать код в try-catch, но мы можем это сделать, если хотим обработать эти исключения.
Errors:
java.lang.Error также является подклассом Throwable, как и исключения, но представ-ляет собой более серьезные проблемы, обычно связанные с JVM или аппаратным обес-печением. Обработка Error обычно невозможна, и программа, скорее всего, завершит-ся. Примеры: OutOfMemoryError, StackOverflowError. Компилятор не требует обработ-ки Error.
Краткая таблица:
Характеристика	Checked Exceptions (ja-va.lang.Exception)	Unchecked Exceptions (ja-va.lang.RuntimeException)	Errors (java.lang.Error)
Наследование	Exception (не RuntimeException)	RuntimeException	Error
Обязательная обработка	Да	Нет	Нет
Примеры	IOException, SQLException	NullPointerException, IllegalArgumentException	OutOfMemoryError
Предназначение	Восстановимые ошибки, тре-бующие обработки	Ошибки программирования, которые нужно исправить	Серьезные си-стемные про-блемы

Когда использовать checked vs. unchecked exceptions?
•	Checked exceptions: Используйте для ситуаций, когда вызывающий код может разумно предвидеть и обработать ошибку. Это часто связано с внешними фак-торами, такими как доступность ресурсов или корректность входных данных.
•	Unchecked exceptions: Используйте для ситуаций, которые, как правило, явля-ются результатом ошибок программирования или ошибок использования API. В этих случаях лучше исправить код, чтобы избежать ошибки, чем пытаться ее об-работать.
В целом, выбор между checked и unchecked exceptions — это вопрос проектирования API и философии. Java склоняется к использованию checked exceptions для более “серь-езных” потенциальных ошибок, требующих явной обработки, и unchecked exceptions для менее ожидаемых ошибок программирования. Но это предмет дебатов, и другие языки (например, C#) придерживаются другой философии (используя в основном unchecked exceptions).

### 11.	Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований порядок блоков исключений)?
Да, в Java один блок catch может отлавливать несколько исключений. Это можно сде-лать двумя способами:
1. Multi-catch (Java 7 и новее):
Начиная с Java 7, можно использовать синтаксис “multi-catch” для отлова нескольких исключений в одном блоке catch. Исключения, которые нужно отловить, перечисляют-ся через символ | (вертикальная черта).
try {
    // Код, который может выбросить IOException или SQLException
    // ...
} catch (IOException | SQLException e) {
    // Обработка IOException или SQLException
    System.err.println("Произошла ошибка ввода-вывода или базы данных: " + e.getMessage());
    e.printStackTrace(); // Для отладки
}
Java
•	Общее поведение: Внутри блока catch с multi-catch переменная исключения (e в примере) будет иметь тип, который является наиболее общим типом для всех пойманных исключений. В данном случае, ес-ли IOException и SQLException не имеют общего предка, кро-ме Exception (или Throwable), то тип e будет выведен как эффектив-ный Exception. Это означает, что вы сможете вызывать только методы, опреде-ленные в Exception (или Throwable). Если вам нужно получить доступ к специ-фичным методам для каждого типа исключения, вам все равно потребуется ис-пользовать instanceof и приведение типа (casting).
•	Объединение обработки: Multi-catch полезен, когда вы хотите выполнить один и тот же код для обработки нескольких типов исключений. Это упрощает код и делает его более читаемым.
•	Разные ветки наследования: Исключения, которые вы отлавливаете с помо-щью multi-catch, могут быть из разных веток наследования.
2. Отлов исключений на уровне общего предка:
Вы можете отловить исключения, у которых есть общий предок, указав в бло-ке catch тип этого общего предка. Например:
try {
    // Код, который может выбросить FileNotFoundException или IOException
    // ...
} catch (IOException e) { // IOException является предком FileNotFoundException
    // Обработка IOException (и, следовательно, FileNotFoundException)
    System.err.println("Произошла ошибка ввода-вывода: " + e.getMessage());
    e.printStackTrace();
}
Java
•	Порядок блоков catch: Крайне важно помнить о порядке блоков catch при отлове исключений с общим предком. Блоки catch должны быть расположе-ны от наиболее специфичного исключения к наиболее общему. Если вы сначала отловите более общее исключение, то более специфичные исключения никогда не будут отловлены, так как более общий catch перехватит их первым. Это при-ведет к ошибке компиляции.
Пример неправильного порядка:
try {
    // ...
} catch (IOException e) {
    // ...
} catch (FileNotFoundException e) { // Ошибка компиляции: Already caught by IO-Exception
    // ...
}
Java
Пример правильного порядка:
try {
    // ...
} catch (FileNotFoundException e) {
    // ...
} catch (IOException e) {
    // ...
}
Java
Рекомендации:
•	Используйте multi-catch (Java 7+) для упрощения кода, когда вы хотите выпол-нить одинаковую обработку для нескольких типов исключений.
•	При отлове исключений с общим предком всегда располагайте блоки catch от наиболее специфичных к наиболее общим.
•	Избегайте отлова Exception или Throwable в начале цепочки catch, если это не абсолютно необходимо, так как это может скрыть более конкретные исключения, которые вы хотели бы обработать по-разному. Лучше отлавливать только те ис-ключения, которые вы действительно знаете, как обработать.
•	Помните, что отлов исключений должен служить цели. Простое перехватывание и игнорирование исключений (пустой блок catch) обычно является плохой прак-тикой, так как это может скрыть важные ошибки и затруднить отладку. В боль-шинстве случаев следует либо зарегистрировать исключение (например, с по-мощью e.printStackTrace()), либо выполнить какие-то действия для исправле-ния проблемы, либо перебросить исключение (возможно, обернув его в другое исключение с более понятным контекстом).

### 12.	Особенность RuntimeException?
RuntimeException в Java занимает особое место в иерархии исключений. Его основная особенность заключается в том, что это базовый класс для так называе-мых непроверяемых (unchecked) исключений. Давайте разберем ключевые аспек-ты RuntimeException:
1. Непроверяемое исключение:
•	Самая важная характеристика RuntimeException (и всех его подклассов) заклю-чается в том, что компилятор Java не требует, чтобы вы обрабатывали эти ис-ключения в блоках try-catch или объявляли их в сигнатуре метода с помо-щью throws.
2. Наследование:
•	RuntimeException является подклассом класса java.lang.Exception.
3. Предназначение:
•	RuntimeException и его подклассы предназначены для представления ошибок программирования, неправильного использования API, или других ситуаций, ко-торые, как правило, указывают на дефекты в коде. Считается, что эти ошибки нужно предотвращать с помощью тщательного программирования, а не пы-таться обрабатывать во время выполнения.
4. Примеры подклассов RuntimeException:
•	NullPointerException: Попытка обратиться к члену объекта, который являет-ся null.
•	ArrayIndexOutOfBoundsException: Попытка обратиться к элементу массива по не-допустимому индексу.
•	IllegalArgumentException: Метод получил аргумент, который не соответствует его требованиям.
•	ClassCastException: Попытка привести объект к типу, к которому он не может быть приведен.
•	ArithmeticException: Например, деление на ноль.
•	NoSuchElementException: Например, попытка получить следующий элемент из пустого итератора.
•	UnsupportedOperationException: Попытка вызвать операцию, которая не под-держивается объектом.
5. Почему они “непроверяемые”?
•	Принудительная обработка всех возможных RuntimeException привела бы к зна-чительному усложнению кода. Во многих случаях, невозможно разумно восста-новиться после этих ошибок во время выполнения.
•	Считается, что лучше исправить код, чтобы избежать возникновения этих ис-ключений, чем пытаться их обработать. Например, вместо того, чтобы постоянно оборачивать код, который может вызвать NullPointerException, в блоки try-catch, лучше убедиться, что переменная никогда не будет null в том месте, где она используется.
6. Когда их все-таки нужно обрабатывать?
•	Хотя компилятор не требует этого, иногда может быть полезно обрабаты-вать RuntimeException в особых ситуациях. Например, если у вас есть критиче-ский участок кода, который должен выполняться несмотря ни на что, вы можете перехватить RuntimeException и предпринять какие-то действия для минимиза-ции ущерба или обеспечения продолжения работы программы (например, запи-сать ошибку в журнал, попытаться повторить операцию, использовать значения по умолчанию). Однако это должно быть исключением, а не правилом.
•	Помните, что обработка RuntimeException не должна заменять исправление ошибки в коде.
7. Создание собственных RuntimeException:
•	Вы можете создавать свои собственные подклассы RuntimeException, если вам нужно создать исключение, которое не нужно проверять при компиляции. Это может быть полезно, если вы хотите обозначить ошибку программирования или неправильное использование вашего API, которое не должно требовать явной обработки вызывающим кодом.
Пример:
public class MyCustomRuntimeException extends RuntimeException {

    public MyCustomRuntimeException(String message) {
        super(message);
    }

    public MyCustomRuntimeException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Использование:
public class Example {
    public void doSomething(int value) {
        if (value < 0) {
            throw new MyCustomRuntimeException("Value must be non-negative"); // Компилятор не требует обработки
        }
        // ...
    }
}
Java
8. RuntimeException и Null Safety (Более современные подходы):
В современном Java, особенно с использованием таких инструментов как Lombok (@NonNull) или статических анализаторов, акцент смещается на предотвращение NullPointerException и других RuntimeException в первую оче-редь. Эти инструменты позволяют вам более явно объявлять, какие переменные не должны быть null, и получать предупреждения во время компиляции, если есть риск обращения к null. Это помогает писать более надежный код с меньшим количе-ством try-catch блоков для RuntimeException.
В заключение:
RuntimeException — это особый вид исключений в Java, которые предназначены для обозначения ошибок программирования и других ситуаций, которые лучше предот-вращать, чем обрабатывать. Компилятор не требует их обработки, но в редких случаях может быть полезно перехватить их для обеспечения надежности критически важных участков кода. Создание собственных RuntimeException может быть полезным для обо-значения ошибок в вашем API, которые не должны требовать явной обработки. Со-временные подходы к программированию на Java все больше склоняются к предот-вращению возникновения RuntimeException с помощью инструментов анализа и прак-тик обеспечения безопасности от null.
