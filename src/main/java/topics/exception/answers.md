### 17. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?
Блок finally выполняется всегда, независимо от того, было ли исключение. Если в блоке finally есть return, он переопределяет возвращаемое значение из блока catch или try.

### 18. Что вы знаете о OutOfMemoryError, SQLException? К какому типу checked или unchecked оно относится, почему?
OutOfMemoryError — это ошибка, которая возникает, когда виртуальная машина Java (JVM) не может выделить достаточно памяти для выполнения операции. Это может произойти, например, при создании большого количества объектов или при попытке загрузить слишком большой файл в память.

OutOfMemoryError относится к unchecked исключениям (непроверяемым).

SQLException — это исключение, которое возникает при работе с базами данных через JDBC (Java Database Connectivity). Оно может быть вызвано различными проблемами, такими как:

- Неправильный SQL-запрос.

- Проблемы с подключением к базе данных.

- Нарушение ограничений базы данных (например, уникальности или внешних ключей).

SQLException относится к checked исключениям (проверяемым).

### 19. Error? В каком случае используется Error. пример Error’а.
Error — это подкласс Throwable, который указывает на серьезные проблемы, с которыми приложение не должно пытаться справиться. Эти проблемы обычно связаны с внутренними сбоями в работе JVM (Java Virtual Machine) или системными ресурсами, и они не могут быть обработаны на уровне приложения.

Error используется для обозначения ситуаций, которые:

- Не могут быть обработаны приложением.

- Не должны быть перехвачены (хотя технически это возможно).

- Указывают на критические сбои, такие как:

  - Недостаток памяти (OutOfMemoryError).

  - Переполнение стека (StackOverflowError).

  - Ошибки загрузки классов (NoClassDefFoundError).

Пример Error:

* OutOfMemoryError
Возникает, когда JVM не может выделить достаточно памяти для создания нового объекта.

        public class Main {
            public static void main(String[] args) {
                try {
                // Попытка создать огромный массив
                   int[] array = new int[Integer.MAX_VALUE];
                } catch (OutOfMemoryError e) {
                   System.out.println("Поймана ошибка: " + e.getMessage());
                }
            }
        }

[← Вернуться к вопросам](README.md)

### 10. Что вы знаете об checked/unchecked исключениях?
В Java исключения являются способом обработки ошибок и необычных ситуаций, которые могут возникнуть во время выполнения программы. Исключения делятся на две основные категории: checked (проверяемые) и unchecked (непроверяемые). Различие между ними заключается в том, как компилятор Java обра-батывает их и какие требования предъявляются к коду, который может их выбросить.
1. Checked Exceptions (Проверяемые исключения):
•	Наследование: Checked exceptions — это подклассы клас-са java.lang.Exception, но не подклассы java.lang.RuntimeException.
•	Обязательная обработка: Ключевая особенность checked exceptions заключа-ется в том, что компилятор Java требует, чтобы код, который может выбросить checked exception, был обработан одним из двух способов:
•	Обработка с помощью try-catch: Код, который может выбросить ис-ключение, должен быть заключен в блок try-catch, где исключение пере-хватывается и обрабатывается.
•	Объявление в сигнатуре метода с помощью throws: Метод, который может выбросить checked exception, должен объявить это в своей сигнату-ре с помощью ключевого слова throws. Это говорит вызывающему мето-ду, что он тоже должен либо обработать исключение, либо объявить его в своей сигнатуре.
•	Примеры: IOException, SQLException, ClassNotFoundException
•	Предназначение: Checked exceptions используются для обозначения ошибок, которые предположительно могут произойти во время нормальной работы про-граммы и которые вызывающий код должен быть готов обработать. Например, попытка открыть файл, который не существует (FileNotFoundException), или по-пытка подключиться к базе данных, которая недоступна (SQLException).
•	Зачем это нужно?: Checked exceptions помогают обеспечить надежность про-граммы, заставляя разработчиков явно учитывать возможность возникновения определенных ошибок и принимать меры для их обработки.
Пример Checked Exception:
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class CheckedExceptionExample {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("nonexistent_file.txt"); // Может выбросить FileNotFoundException
            fis.read(); // Может выбросить IOException
        } catch (FileNotFoundException e) {
            System.err.println("Файл не найден: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("Ошибка ввода/вывода: " + e.getMessage());
        }
    }
}
В этом примере, если мы не обернем вызов FileInputStream и fis.read() в блоки try-catch, компилятор выдаст ошибку, потому что FileNotFoundException и IOException являются checked exceptions. Мы обязаны их обработать. 
2. Unchecked Exceptions (Непроверяемые исключения):
•	Наследование: Unchecked exceptions — это подклассы клас-са java.lang.RuntimeException или java.lang.Error.
•	Необязательная обработка: Компилятор Java не требует, чтобы код, кото-рый может выбросить unchecked exception, был обработан или объявлен в сигна-туре метода.
•	Примеры: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException, ArithmeticException (деление на ноль), OutOfMemoryError, StackOverflowError.
•	Предназначение: Unchecked exceptions используются для обозначения ошибок программирования, ошибок использования API, или серьезных системных оши-бок, которые обычно нельзя разумно восстановить во время выполнения. Счи-тается, что эти ошибки должны быть исправлены в коде, а не обрабатываться во время выполнения.
•	Зачем это нужно?: Требование обрабатывать все unchecked exceptions услож-нило бы код без особой пользы, так как они часто являются следствием фунда-ментальных ошибок. Считается, что разработчик должен избегать этих ошибок в первую очередь.
Пример Unchecked Exception:
public class UncheckedExceptionExample {
    public static void main(String[] args) {
        String str = null;
        try {
            int length = str.length(); // Может выбросить NullPointerException
            System.out.println("Длина строки: " + length);
        } catch (NullPointerException e) {
            System.err.println("Попытка обратиться к null: " + e.getMessage());
        }

        int[] arr = new int[5];
        try {
           int value = arr[10]; // Может выбросить ArrayIndexOutOfBoundsExcep-tion
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println("Выход за границы массива");
        }
    }
}

В этом примере NullPointerException и ArrayIndexOutOfBoundsException являются un-checked exceptions. Компилятор не заставляет нас оборачивать код в try-catch, но мы можем это сделать, если хотим обработать эти исключения.
Errors:
java.lang.Error также является подклассом Throwable, как и исключения, но представ-ляет собой более серьезные проблемы, обычно связанные с JVM или аппаратным обес-печением. Обработка Error обычно невозможна, и программа, скорее всего, завершит-ся. Примеры: OutOfMemoryError, StackOverflowError. Компилятор не требует обработ-ки Error.
Краткая таблица:
Характеристика	Checked Exceptions (ja-va.lang.Exception)	Unchecked Exceptions (ja-va.lang.RuntimeException)	Errors (java.lang.Error)
Наследование	Exception (не RuntimeException)	RuntimeException	Error
Обязательная обработка	Да	Нет	Нет
Примеры	IOException, SQLException	NullPointerException, IllegalArgumentException	OutOfMemoryError
Предназначение	Восстановимые ошибки, тре-бующие обработки	Ошибки программирования, которые нужно исправить	Серьезные си-стемные про-блемы

Когда использовать checked vs. unchecked exceptions?
•	Checked exceptions: Используйте для ситуаций, когда вызывающий код может разумно предвидеть и обработать ошибку. Это часто связано с внешними фак-торами, такими как доступность ресурсов или корректность входных данных.
•	Unchecked exceptions: Используйте для ситуаций, которые, как правило, явля-ются результатом ошибок программирования или ошибок использования API. В этих случаях лучше исправить код, чтобы избежать ошибки, чем пытаться ее об-работать.
В целом, выбор между checked и unchecked exceptions — это вопрос проектирования API и философии. Java склоняется к использованию checked exceptions для более “серь-езных” потенциальных ошибок, требующих явной обработки, и unchecked exceptions для менее ожидаемых ошибок программирования. Но это предмет дебатов, и другие языки (например, C#) придерживаются другой философии (используя в основном unchecked exceptions).

### 11.	Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований порядок блоков исключений)?
Да, в Java один блок catch может отлавливать несколько исключений. Это можно сде-лать двумя способами:
1. Multi-catch (Java 7 и новее):
Начиная с Java 7, можно использовать синтаксис “multi-catch” для отлова нескольких исключений в одном блоке catch. Исключения, которые нужно отловить, перечисляют-ся через символ | (вертикальная черта).
try {
    // Код, который может выбросить IOException или SQLException
    // ...
} catch (IOException | SQLException e) {
    // Обработка IOException или SQLException
    System.err.println("Произошла ошибка ввода-вывода или базы данных: " + e.getMessage());
    e.printStackTrace(); // Для отладки
}
Java
•	Общее поведение: Внутри блока catch с multi-catch переменная исключения (e в примере) будет иметь тип, который является наиболее общим типом для всех пойманных исключений. В данном случае, ес-ли IOException и SQLException не имеют общего предка, кро-ме Exception (или Throwable), то тип e будет выведен как эффектив-ный Exception. Это означает, что вы сможете вызывать только методы, опреде-ленные в Exception (или Throwable). Если вам нужно получить доступ к специ-фичным методам для каждого типа исключения, вам все равно потребуется ис-пользовать instanceof и приведение типа (casting).
•	Объединение обработки: Multi-catch полезен, когда вы хотите выполнить один и тот же код для обработки нескольких типов исключений. Это упрощает код и делает его более читаемым.
•	Разные ветки наследования: Исключения, которые вы отлавливаете с помо-щью multi-catch, могут быть из разных веток наследования.
2. Отлов исключений на уровне общего предка:
Вы можете отловить исключения, у которых есть общий предок, указав в бло-ке catch тип этого общего предка. Например:
try {
    // Код, который может выбросить FileNotFoundException или IOException
    // ...
} catch (IOException e) { // IOException является предком FileNotFoundException
    // Обработка IOException (и, следовательно, FileNotFoundException)
    System.err.println("Произошла ошибка ввода-вывода: " + e.getMessage());
    e.printStackTrace();
}
Java
•	Порядок блоков catch: Крайне важно помнить о порядке блоков catch при отлове исключений с общим предком. Блоки catch должны быть расположе-ны от наиболее специфичного исключения к наиболее общему. Если вы сначала отловите более общее исключение, то более специфичные исключения никогда не будут отловлены, так как более общий catch перехватит их первым. Это при-ведет к ошибке компиляции.
Пример неправильного порядка:
try {
    // ...
} catch (IOException e) {
    // ...
} catch (FileNotFoundException e) { // Ошибка компиляции: Already caught by IO-Exception
    // ...
}
Java
Пример правильного порядка:
try {
    // ...
} catch (FileNotFoundException e) {
    // ...
} catch (IOException e) {
    // ...
}
Java
Рекомендации:
•	Используйте multi-catch (Java 7+) для упрощения кода, когда вы хотите выпол-нить одинаковую обработку для нескольких типов исключений.
•	При отлове исключений с общим предком всегда располагайте блоки catch от наиболее специфичных к наиболее общим.
•	Избегайте отлова Exception или Throwable в начале цепочки catch, если это не абсолютно необходимо, так как это может скрыть более конкретные исключения, которые вы хотели бы обработать по-разному. Лучше отлавливать только те ис-ключения, которые вы действительно знаете, как обработать.
•	Помните, что отлов исключений должен служить цели. Простое перехватывание и игнорирование исключений (пустой блок catch) обычно является плохой прак-тикой, так как это может скрыть важные ошибки и затруднить отладку. В боль-шинстве случаев следует либо зарегистрировать исключение (например, с по-мощью e.printStackTrace()), либо выполнить какие-то действия для исправле-ния проблемы, либо перебросить исключение (возможно, обернув его в другое исключение с более понятным контекстом).

### 12.	Особенность RuntimeException?
RuntimeException в Java занимает особое место в иерархии исключений. Его основная особенность заключается в том, что это базовый класс для так называе-мых непроверяемых (unchecked) исключений. Давайте разберем ключевые аспек-ты RuntimeException:
1. Непроверяемое исключение:
•	Самая важная характеристика RuntimeException (и всех его подклассов) заклю-чается в том, что компилятор Java не требует, чтобы вы обрабатывали эти ис-ключения в блоках try-catch или объявляли их в сигнатуре метода с помо-щью throws.
2. Наследование:
•	RuntimeException является подклассом класса java.lang.Exception.
3. Предназначение:
•	RuntimeException и его подклассы предназначены для представления ошибок программирования, неправильного использования API, или других ситуаций, ко-торые, как правило, указывают на дефекты в коде. Считается, что эти ошибки нужно предотвращать с помощью тщательного программирования, а не пы-таться обрабатывать во время выполнения.
4. Примеры подклассов RuntimeException:
•	NullPointerException: Попытка обратиться к члену объекта, который являет-ся null.
•	ArrayIndexOutOfBoundsException: Попытка обратиться к элементу массива по не-допустимому индексу.
•	IllegalArgumentException: Метод получил аргумент, который не соответствует его требованиям.
•	ClassCastException: Попытка привести объект к типу, к которому он не может быть приведен.
•	ArithmeticException: Например, деление на ноль.
•	NoSuchElementException: Например, попытка получить следующий элемент из пустого итератора.
•	UnsupportedOperationException: Попытка вызвать операцию, которая не под-держивается объектом.
5. Почему они “непроверяемые”?
•	Принудительная обработка всех возможных RuntimeException привела бы к зна-чительному усложнению кода. Во многих случаях, невозможно разумно восста-новиться после этих ошибок во время выполнения.
•	Считается, что лучше исправить код, чтобы избежать возникновения этих ис-ключений, чем пытаться их обработать. Например, вместо того, чтобы постоянно оборачивать код, который может вызвать NullPointerException, в блоки try-catch, лучше убедиться, что переменная никогда не будет null в том месте, где она используется.
6. Когда их все-таки нужно обрабатывать?
•	Хотя компилятор не требует этого, иногда может быть полезно обрабаты-вать RuntimeException в особых ситуациях. Например, если у вас есть критиче-ский участок кода, который должен выполняться несмотря ни на что, вы можете перехватить RuntimeException и предпринять какие-то действия для минимиза-ции ущерба или обеспечения продолжения работы программы (например, запи-сать ошибку в журнал, попытаться повторить операцию, использовать значения по умолчанию). Однако это должно быть исключением, а не правилом.
•	Помните, что обработка RuntimeException не должна заменять исправление ошибки в коде.
7. Создание собственных RuntimeException:
•	Вы можете создавать свои собственные подклассы RuntimeException, если вам нужно создать исключение, которое не нужно проверять при компиляции. Это может быть полезно, если вы хотите обозначить ошибку программирования или неправильное использование вашего API, которое не должно требовать явной обработки вызывающим кодом.
Пример:
public class MyCustomRuntimeException extends RuntimeException {

    public MyCustomRuntimeException(String message) {
        super(message);
    }

    public MyCustomRuntimeException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Использование:
public class Example {
    public void doSomething(int value) {
        if (value < 0) {
            throw new MyCustomRuntimeException("Value must be non-negative"); // Компилятор не требует обработки
        }
        // ...
    }
}
Java
8. RuntimeException и Null Safety (Более современные подходы):
В современном Java, особенно с использованием таких инструментов как Lombok (@NonNull) или статических анализаторов, акцент смещается на предотвращение NullPointerException и других RuntimeException в первую оче-редь. Эти инструменты позволяют вам более явно объявлять, какие переменные не должны быть null, и получать предупреждения во время компиляции, если есть риск обращения к null. Это помогает писать более надежный код с меньшим количе-ством try-catch блоков для RuntimeException.
В заключение:
RuntimeException — это особый вид исключений в Java, которые предназначены для обозначения ошибок программирования и других ситуаций, которые лучше предот-вращать, чем обрабатывать. Компилятор не требует их обработки, но в редких случаях может быть полезно перехватить их для обеспечения надежности критически важных участков кода. Создание собственных RuntimeException может быть полезным для обо-значения ошибок в вашем API, которые не должны требовать явной обработки. Со-временные подходы к программированию на Java все больше склоняются к предот-вращению возникновения RuntimeException с помощью инструментов анализа и прак-тик обеспечения безопасности от null.
