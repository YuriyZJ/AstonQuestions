### 1. Что такое Stream API?
    это абстракция (API появилось в JAVA 8), представляющая последовательность элементов, над которой можно выполнять 
    различные операции (фильтрацию, преобразование, агрегацию и т.д.). Это не структура данных, а инструмент для 
    эффективной обработки данных из источника (коллекции, массивы, I/O, генераторы и т.д.). Он позволяет выполнять 
    сложные операции (фильтрацию, преобразование, сортировку, агрегацию) с помощью цепочек методов, что делает 
    код более декларативным и читаемым. Поток — это "конвейер", через который элементы проходят от источника к 
    результату. Операции объединяются в цепочку (как в функциональном программировании).
### 2. Каковы основные преимущества использования Stream API?
    Не хранит данные. Stream лишь обрабатывает элементы источника (коллекция, массив, I/O-ресурс).
    Потокобезопасность: Stream API не изменяет исходные данные, а создает новые потоки.
    Параллелизм: Метод parallelStream() позволяет автоматически распараллеливать операции.
    Интеграция с функциональными интерфейсами: Использование лямбда-выражений и методов-ссылок (String::toUpperCase) 
    делает код лаконичным.
### 3. Какие основные операции доступны в Stream API?
    Промежуточные операции(Эти операции не выполняются до вызова терминальной. Возвращают новый поток):
        filter(Predicate<T>) - Фильтрует элементы по условию
        map(Function<T, R>) - Преобразует каждый элемент в другой объект.
        flatMap(Function<T, Stream<R>>) - "Расплющивает" вложенные структуры в один поток.
        sorted() / sorted(Comparator<T>) - Сортирует элементы (натуральным порядком или через Comparator).
        distinct() - Удаляет дубликаты (использует equals() для сравнения).
        limit(long maxSize) - Ограничивает количество элементов в потоке.
        skip(long n) - Пропускает первые n элементов.
        peek(Consumer<T>) - Выполняет действие для каждого элемента без изменения потока (часто для отладки).
    Терминальные операции(Запускают выполнение потока и закрывают его):
        collect(Collector<T, A, R>) - Собирает элементы в коллекцию или другую структуру.
        forEach(Consumer<T>) - Выполняет действие для каждого элемента.
        reduce(BinaryOperator<T>) - Агрегирует элементы в одно значение (например, сумма)
        min(Comparator<T>) / max(Comparator<T>) - Находит минимальный/максимальный элемент через Comparator
        count() - Возвращает количество элементов в потоке.
    Полезные утилиты в Collectors:
        toList(), toSet(), toMap() — сбор в коллекции
        joining(delimiter) — объединение строк.
        groupingBy() — группировка элементов.
        partitioningBy() — разделение на две группы по условию.
        counting(), summingInt(), averagingDouble() — агрегация.
### 4. Как можно объединять несколько Stream с помощью Stream API?
### 5. Как использовать Stream API для обработки ошибок?
### 6. Как использовать методы фильтрации в Stream API, что принимает/возвращает?
### 7. Как применять Collectors.groupingBy() Stream API, что принимает\возвращает?
### 8. Как можно использовать Stream API для преобразования одного типа данных в другой, например int[] 1,2,3?
### 9. Отличия flatMap от map.
### 10. Как работать с параллельными потоками с помощью Stream API?
### 11. Как использовать метод forEach в Stream API? - что принимает\возвращает?
### 12. Как использовать метод peek в Stream API? - что принимает\возвращает?
### 13. Как работает метод reduce в Stream API? - что принимает\возвращает? Варианты методы.
### 14. Как создать бесконечный поток с помощью Stream API?
### 15. Какие ограничения есть у Stream API?
### 16. Как передать переменную в стрим что с ней можно сделать?
### 17. Как создать Optional?
### 18. Отличие Optional of() nulable()?
### 19. В чем отличие методов ifPresent и orElse в контексте Optional?
### 20. Каким образом можно объединить два Optional в один, используя метод join?
### 21. Что проверяет ifPresent Optional?
### 22. Каким образом можно преобразовать Stream в массив или коллекцию?
### 23. В чём отличие методов orElseGet и orElse?
### 24. Каким образом можно реализовать обработку ошибок с использованием Optional и метод orElseThrow?


[← Вернуться к вопросам](README.md)