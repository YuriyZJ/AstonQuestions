### 1. Что такое Stream API?
    это абстракция (API появилось в JAVA 8), представляющая последовательность элементов, над которой можно выполнять 
    различные операции (фильтрацию, преобразование, агрегацию и т.д.). Это не структура данных, а инструмент для 
    эффективной обработки данных из источника (коллекции, массивы, I/O, генераторы и т.д.). Он позволяет выполнять 
    сложные операции (фильтрацию, преобразование, сортировку, агрегацию) с помощью цепочек методов, что делает 
    код более декларативным и читаемым. Поток — это "конвейер", через который элементы проходят от источника к 
    результату. Операции объединяются в цепочку (как в функциональном программировании).
### 2. Каковы основные преимущества использования Stream API?
    Не хранит данные. Stream лишь обрабатывает элементы источника (коллекция, массив, I/O-ресурс).
    Потокобезопасность: Stream API не изменяет исходные данные, а создает новые потоки.
    Параллелизм: Метод parallelStream() позволяет автоматически распараллеливать операции.
    Интеграция с функциональными интерфейсами: Использование лямбда-выражений и методов-ссылок (String::toUpperCase) 
    делает код лаконичным.
### 3. Какие основные операции доступны в Stream API?
    Промежуточные операции(Эти операции не выполняются до вызова терминальной. Возвращают новый поток):
        filter(Predicate<T>) - Фильтрует элементы по условию
        map(Function<T, R>) - Преобразует каждый элемент в другой объект.
        flatMap(Function<T, Stream<R>>) - "Расплющивает" вложенные структуры в один поток.
        sorted() / sorted(Comparator<T>) - Сортирует элементы (натуральным порядком или через Comparator).
        distinct() - Удаляет дубликаты (использует equals() для сравнения).
        limit(long maxSize) - Ограничивает количество элементов в потоке.
        skip(long n) - Пропускает первые n элементов.
        peek(Consumer<T>) - Выполняет действие для каждого элемента без изменения потока (часто для отладки).
    Терминальные операции(Запускают выполнение потока и закрывают его):
        collect(Collector<T, A, R>) - Собирает элементы в коллекцию или другую структуру.
        forEach(Consumer<T>) - Выполняет действие для каждого элемента.
        reduce(BinaryOperator<T>) - Агрегирует элементы в одно значение (например, сумма)
        min(Comparator<T>) / max(Comparator<T>) - Находит минимальный/максимальный элемент через Comparator
        count() - Возвращает количество элементов в потоке.
    Полезные утилиты в Collectors:
        toList(), toSet(), toMap() — сбор в коллекции
        joining(delimiter) — объединение строк.
        groupingBy() — группировка элементов.
        partitioningBy() — разделение на две группы по условию.
        counting(), summingInt(), averagingDouble() — агрегация.
### 4. Как можно объединять несколько Stream с помощью Stream API?
    Способы объединения потоков:
    1. Использование метода Stream.concat(Stream<T> a, Stream<T> b)
    Этот статический метод позволяет объединить ровно два потока в один. В результате получается поток, в котором 
    сначала идут элементы первого, а затем — второго потока.
    Замечания:
    Ленивость вычислений: Потоки в Java вычисляются лениво, поэтому объединённый поток не выполнит никаких операций до
    вызова терминального метода (например, forEach, collect).
    Одноразовость: Потоки можно использовать только один раз. После выполнения терминальной операции их повторно 
    использовать нельзя.
    2. Объединение более чем двух потоков
    Если требуется объединить более двух потоков, можно воспользоваться методом Stream.of(...) для создания потока, 
    содержащего другие потоки, а затем применить flatMap для «распаковки» вложенных потоков в один общий поток.
    Важные моменты при объединении потоков
    Если объединяемые потоки упорядочены, то результирующий поток также будет упорядоченным.
    Если один из потоков является параллельным, то при объединении порядок выполнения может зависеть от способа 
    объединения. Обычно рекомендуется приводить все потоки к одному режиму (либо последовательному, либо параллельному)
    для предсказуемости.
### 5. Как использовать Stream API для обработки ошибок?
    В Stream API отсутствует встроенный механизм для обработки исключений, но можно использовать try-catch внутри 
    map() или filter(), а также написать обёртку для методов, которые выбрасывают исключения.
    Подходы для обработки ошибок
    1. Использование конструкции try-catch внутри лямбда-выражения
    Можно обернуть потенциально опасный код в отдельный метод, в котором реализована обработка исключения. При этом метод
    может возвращать Optional<T>, либо специальное значение (например, null), которое потом можно отфильтровать.    
    2. Оборачивание лямбда-выражений в специальные функции
    Можно написать вспомогательный метод, который принимает функцию, способную бросать исключения, и возвращает функцию,
    обрабатывающую исключения. Такой подход помогает «очистить» основной поток от лишних конструкций try-catch.
### 6. Как использовать методы фильтрации в Stream API, что принимает/возвращает?
    Метод filter(Predicate<T> predicate)
    Метод filter является одним из ключевых методов Stream API и используется для отбора элементов на основе заданного
    условия. Он позволяет «отфильтровать» поток так, чтобы в результирующем потоке оказались только те элементы, для
    которых условие (предикат) возвращает true.
    Принимает: объект типа Predicate<T>, который представляет собой функциональный интерфейс с методом test(T t),
    возвращающим boolean.
    Возвращает: новый поток (Stream<T>), содержащий только те элементы исходного потока, для которых предикат вернул true.
    Метод filter можно применять и к объектам типа Optional. В этом случае он фильтрует значение внутри Optional,
    оставляя его только если условие истинно.
    Можно применять несколько вызовов метода filter, чтобы последовательно отфильтровать поток по разным условиям.
    Каждый вызов filter создает новый промежуточный поток, содержащий только те элементы, которые удовлетворяют
    указанному условию.
    Важные моменты
    Ленивая оценка: Фильтр применяется только в момент выполнения терминальных операций, поэтому вычисления происходят
    «по требованию».
    Неповреждение исходного потока: Каждый вызов метода filter возвращает новый поток, исходный поток при этом
    остается неизменным.
    Композиционность: Благодаря возможности цепочки вызовов, можно строить сложные фильтры, комбинируя простые
    логические условия.
### 7. Как применять Collectors.groupingBy() Stream API, что принимает\возвращает?
### 8. Как можно использовать Stream API для преобразования одного типа данных в другой, например int[] 1,2,3?
### 9. Отличия flatMap от map.
### 10. Как работать с параллельными потоками с помощью Stream API?
### 11. Как использовать метод forEach в Stream API? - что принимает\возвращает?
### 12. Как использовать метод peek в Stream API? - что принимает\возвращает?
### 13. Как работает метод reduce в Stream API? - что принимает\возвращает? Варианты методы.
### 14. Как создать бесконечный поток с помощью Stream API?
### 15. Какие ограничения есть у Stream API?
### 16. Как передать переменную в стрим что с ней можно сделать?
### 17. Как создать Optional?
### 18. Отличие Optional of() nulable()?
### 19. В чем отличие методов ifPresent и orElse в контексте Optional?
### 20. Каким образом можно объединить два Optional в один, используя метод join?
### 21. Что проверяет ifPresent Optional?
### 22. Каким образом можно преобразовать Stream в массив или коллекцию?
### 23. В чём отличие методов orElseGet и orElse?
### 24. Каким образом можно реализовать обработку ошибок с использованием Optional и метод orElseThrow?


[← Вернуться к вопросам](README.md)