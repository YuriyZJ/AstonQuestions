### 1. Что такое Stream API?
    это абстракция (API появилось в JAVA 8), представляющая последовательность элементов, над которой можно выполнять 
    различные операции (фильтрацию, преобразование, агрегацию и т.д.). Это не структура данных, а инструмент для 
    эффективной обработки данных из источника (коллекции, массивы, I/O, генераторы и т.д.). Он позволяет выполнять 
    сложные операции (фильтрацию, преобразование, сортировку, агрегацию) с помощью цепочек методов, что делает 
    код более декларативным и читаемым. Поток — это "конвейер", через который элементы проходят от источника к 
    результату. Операции объединяются в цепочку (как в функциональном программировании).
### 2. Каковы основные преимущества использования Stream API?
    Не хранит данные. Stream лишь обрабатывает элементы источника (коллекция, массив, I/O-ресурс).
    Потокобезопасность: Stream API не изменяет исходные данные, а создает новые потоки.
    Параллелизм: Метод parallelStream() позволяет автоматически распараллеливать операции.
    Интеграция с функциональными интерфейсами: Использование лямбда-выражений и методов-ссылок (String::toUpperCase) 
    делает код лаконичным.
### 3. Какие основные операции доступны в Stream API?
    Промежуточные операции(Эти операции не выполняются до вызова терминальной. Возвращают новый поток):
        filter(Predicate<T>) - Фильтрует элементы по условию
        map(Function<T, R>) - Преобразует каждый элемент в другой объект.
        flatMap(Function<T, Stream<R>>) - "Расплющивает" вложенные структуры в один поток.
        sorted() / sorted(Comparator<T>) - Сортирует элементы (натуральным порядком или через Comparator).
        distinct() - Удаляет дубликаты (использует equals() для сравнения).
        limit(long maxSize) - Ограничивает количество элементов в потоке.
        skip(long n) - Пропускает первые n элементов.
        peek(Consumer<T>) - Выполняет действие для каждого элемента без изменения потока (часто для отладки).
    Терминальные операции(Запускают выполнение потока и закрывают его):
        collect(Collector<T, A, R>) - Собирает элементы в коллекцию или другую структуру.
        forEach(Consumer<T>) - Выполняет действие для каждого элемента.
        reduce(BinaryOperator<T>) - Агрегирует элементы в одно значение (например, сумма)
        min(Comparator<T>) / max(Comparator<T>) - Находит минимальный/максимальный элемент через Comparator
        count() - Возвращает количество элементов в потоке.
    Полезные утилиты в Collectors:
        toList(), toSet(), toMap() — сбор в коллекции
        joining(delimiter) — объединение строк.
        groupingBy() — группировка элементов.
        partitioningBy() — разделение на две группы по условию.
        counting(), summingInt(), averagingDouble() — агрегация.
### 4. Как можно объединять несколько Stream с помощью Stream API?
    Способы объединения потоков:
    1. Использование метода Stream.concat(Stream<T> a, Stream<T> b)
    Этот статический метод позволяет объединить ровно два потока в один. В результате получается поток, в котором 
    сначала идут элементы первого, а затем — второго потока.
    Замечания:
    Ленивость вычислений: Потоки в Java вычисляются лениво, поэтому объединённый поток не выполнит никаких операций до
    вызова терминального метода (например, forEach, collect).
    Одноразовость: Потоки можно использовать только один раз. После выполнения терминальной операции их повторно 
    использовать нельзя.
    2. Объединение более чем двух потоков
    Если требуется объединить более двух потоков, можно воспользоваться методом Stream.of(...) для создания потока, 
    содержащего другие потоки, а затем применить flatMap для «распаковки» вложенных потоков в один общий поток.
    Важные моменты при объединении потоков
    Если объединяемые потоки упорядочены, то результирующий поток также будет упорядоченным.
    Если один из потоков является параллельным, то при объединении порядок выполнения может зависеть от способа 
    объединения. Обычно рекомендуется приводить все потоки к одному режиму (либо последовательному, либо параллельному)
    для предсказуемости.
### 5. Как использовать Stream API для обработки ошибок?
    В Stream API отсутствует встроенный механизм для обработки исключений, но можно использовать try-catch внутри 
    map() или filter(), а также написать обёртку для методов, которые выбрасывают исключения.
    Подходы для обработки ошибок
    1. Использование конструкции try-catch внутри лямбда-выражения
    Можно обернуть потенциально опасный код в отдельный метод, в котором реализована обработка исключения. При этом метод
    может возвращать Optional<T>, либо специальное значение (например, null), которое потом можно отфильтровать.    
    2. Оборачивание лямбда-выражений в специальные функции
    Можно написать вспомогательный метод, который принимает функцию, способную бросать исключения, и возвращает функцию,
    обрабатывающую исключения. Такой подход помогает «очистить» основной поток от лишних конструкций try-catch.
### 6. Как использовать методы фильтрации в Stream API, что принимает/возвращает?
    Метод filter(Predicate<T> predicate)
    Метод filter является одним из ключевых методов Stream API и используется для отбора элементов на основе заданного
    условия. Он позволяет «отфильтровать» поток так, чтобы в результирующем потоке оказались только те элементы, для
    которых условие (предикат) возвращает true.
    Принимает: объект типа Predicate<T>, который представляет собой функциональный интерфейс с методом test(T t),
    возвращающим boolean.
    Возвращает: новый поток (Stream<T>), содержащий только те элементы исходного потока, для которых предикат вернул true.
    Метод filter можно применять и к объектам типа Optional. В этом случае он фильтрует значение внутри Optional,
    оставляя его только если условие истинно.
    Можно применять несколько вызовов метода filter, чтобы последовательно отфильтровать поток по разным условиям.
    Каждый вызов filter создает новый промежуточный поток, содержащий только те элементы, которые удовлетворяют
    указанному условию.
    Важные моменты
    Ленивая оценка: Фильтр применяется только в момент выполнения терминальных операций, поэтому вычисления происходят
    «по требованию».
    Неповреждение исходного потока: Каждый вызов метода filter возвращает новый поток, исходный поток при этом
    остается неизменным.
    Композиционность: Благодаря возможности цепочки вызовов, можно строить сложные фильтры, комбинируя простые
    логические условия.
### 7. Как применять Collectors.groupingBy() Stream API, что принимает\возвращает?
### 8. Как можно использовать Stream API для преобразования одного типа данных в другой, например int[] 1,2,3?
### 9. Отличия flatMap от map.
### 10. Как работать с параллельными потоками с помощью Stream API?
### 11. Как использовать метод forEach в Stream API? - что принимает\возвращает?
### 12. Как использовать метод peek в Stream API? - что принимает\возвращает?
### 13. Как работает метод reduce в Stream API? - что принимает\возвращает? Варианты методы.
### 14. Как создать бесконечный поток с помощью Stream API?
    Бесконечный поток можно создать двумя основными способами:
    1. Используя метод Stream.generate(Supplier<T>).
        Supplier – это функциональный интерфейс (функция-поставщик), который предоставляет значения для потока данных.
    Она используется для создания бесконечных потоков, генерируя новые элементы по запросу. В отличие от традиционных
    коллекций, поток данных обрабатывается лениво, то есть элементы создаются и обрабатываются только тогда, когда это
    необходимо.
    Этот метод принимает функцию-поставщик Supplier, которая возвращает новые элементы потока. Каждый вызов 
    функции-поставщика генерирует новое значение, и поток будет продолжать генерироваться бесконечно, пока не будет
    ограничено каким-то внешним условием.
    2. Используя метод Stream.iterate(T seed, UnaryOperator<T>).
        T seed – начальное значение, с которого начинается поток. Это может быть любое значение типа Т, например, целое
    число, строка или другой объект.
        UnaryOperator<T> - функция, принимающая один аргумент типа Т и возвращающая значение того же типа. Эта функция
    определяет, как генерируются последующие элементы потока на основе предыдущего элемента.
    Этот метод принимает начальное значение seed и функцию, которая определяет, как получить следующий элемент на основе
    предыдущего. Поток будет продолжать генерировать новые элементы бесконечно, основываясь на применении функции к
    предыдущему элементу.
### 15. Какие ограничения есть у Stream API?
    1. Отсутствие поддержки параллельных структур данных.
    Stream API не поддерживает параллельные структуры данных, такие как списки или карты. Все операции выполняются
    последовательно над элементами потока, даже если поток был распараллелен. Параллельное выполнение может улучшить
    производительность, но его эффективность сильно зависит от характера данных и задач.
    2. Ограниченная поддержка операций с состоянием.
    Некоторые операции, такие как сортировка или группировка, требуют сохранения состояния, что может негативно сказываться
    на производительности и потреблении памяти. Хотя Stream API пытается минимизировать эту проблему, важно учитывать, что
    обработка больших объемов данных может потребовать значительных ресурсов.
    3. Отсутствует прямой доступ к индексам элементов.
    При работе с потоками вы не имеете прямого доступа к индексам элементов. Например, вы не сможете легко обратиться к
    элементу по его позиции в потоке. Для таких целей лучше использовать традиционные коллекции, такие как List.
    4. Невозможность многократного прохода по одному и тому же потоку.
    После завершения обработки потока он закрывается, и вы не можете повторно пройти по этому потоку. Если вам нужно
    обработать одни и те же данные несколько раз, вам придется заново создавать поток.
    5. Ограниченная поддержка циклов и итераций.
    Stream API не поддерживает традиционные циклы, такие как for или while. Вместо этого он полагается на функциональные
    стили программирования, такие как map-reduce, filter и collect. Это может затруднить реализацию некоторых задач,
    которые традиционно решались с помощью циклов.
    6. Сложность в отладке.
    Хотя Stream API упрощает написание кода, его отладка может быть сложной задачей. Визуализация цепочки операций и
    отслеживание промежуточных состояний потока могут требовать специальных инструментов и подходов.
    7. Проблемы с производительностью при неправильной настройке параллельной обработки.
    Неправильная настройка параллельного выполнения потоков может привести к снижению производительности. Особенно это
    актуально для небольших наборов данных, где накладные расходы на создание и управление потоками могут превышать выгоды
    от параллелизма.
    8. Ограничения в обработке больших объемов данных.
    Stream API эффективен для работы с большими объемами данных, но при этом требует достаточно памяти для хранения
    промежуточных результатов. В некоторых случаях традиционные итераторы могут оказаться более подходящими.
    9. Меньшая гибкость в сравнении с традиционными циклами.
    Stream API предлагает фиксированный набор операций, таких как фильтрация, отображение и свертка. Эти операции удобны
    для большинства стандартных задач, но могут быть недостаточны для более специализированных сценариев.
    10. Недостаточная поддержка сторонними библиотеками.
    Несмотря на популярность Stream API, многие сторонние библиотеки и фреймворки не поддерживают его напрямую. Это может
    усложнять интеграцию и требовать дополнительных усилий для адаптации существующих решений.
### 16. Как передать переменную в стрим что с ней можно сделать?
    Передача переменной в Stream позволяет обрабатывать данные последовательно и параллельно, применяя различные операции,
    такие как фильтрация, преобразование, сортировка и агрегация. Потоки поддерживают ленивые вычисления, что делает их
    эффективными для работы с большими объемами данных.
    Основные шаги передачи переменной в Stream:
    1. Создание источника данных.
    Можно использовать массивы, коллекции или генераторы для создания потока.
    2. Применение промежуточных операций.
    Промежуточные операции, такие как map, filter, sorted, применяются к каждому элементу потока.
    3. Завершение потока терминальной операцией.
    Терминальная операция, такая как collect, reduce, findAny, инициирует обработку потока и возвращает результат.
    Операции с переменной в Stream:
    1. Преобразование (map). Преобразование каждого элемента потока в другой элемент.
    2. Фильтрация (filter). Отбор элементов, удовлетворяющих определенному условию.
    3. Сортировка (sorted). Упорядочивание элементов потока.
    4. Агрегация (reduce). Выполнение операции свертки, например, суммирования или умножения.
    5. Коллектор (collect). Сбор результатов в коллекцию или другой контейнер.
    6. Поиск (findAny, findFirst). Нахождение первого подходящего элемента.
    7. Параллельная обработка (parallel). Разделение потока на несколько частей для параллельной обработки.
### 17. Как создать Optional?
### 18. Отличие Optional of() nulable()?
### 19. В чем отличие методов ifPresent и orElse в контексте Optional?
### 20. Каким образом можно объединить два Optional в один, используя метод join?
### 21. Что проверяет ifPresent Optional?
### 22. Каким образом можно преобразовать Stream в массив или коллекцию?
### 23. В чём отличие методов orElseGet и orElse?
### 24. Каким образом можно реализовать обработку ошибок с использованием Optional и метод orElseThrow?


[← Вернуться к вопросам](README.md)
