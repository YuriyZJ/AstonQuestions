### 6. Расскажите про модификаторы доступа, к чему они применяются.
Модификаторы — это специальные слова языка Java, которые вы можете использовать для изменения элементов (классов, методов, переменных). В Java есть две категории модификаторов: модификаторы доступа и другие модификаторы.
Модификаторы доступа определяют область видимости и доступность классов, методов, полей и конструкторов. В Java есть четыре уровня доступа:
* public - открытый элемент. Доступ к нему можно получить из класса, снаружи класса, внутри и снаружи пакета, в пределах одного проекта (Java файл может иметь только один public класс и множество подклассов). Используется, если класс или его члены должны быть доступны в любой точке программы;

        public class Example {
            public int value;
        
            public void show() {
                System.out.println("Public method");
            }
        }

* private — доступ только внутри того же класса. Применяется для инкапсуляции данных, чтобы ограничить прямой доступ к полям и методам;

        class Example {
          private int value; // доступен только внутри Example
        
          private void show() {
              System.out.println("Private method");
          }
        }
* default — элементу с модификатором по умолчанию, есть доступ только внутри пакета. Устанавливается ко всем полям и методам, в которых не подставлены другие модификаторы. Применяется, когда нет необходимости предоставлять доступ извне пакета;

        class Example {
           int value; // доступен внутри пакета
        }
* protected — можно получить доступ внутри и снаружи пакета через дочерний класс и только в классе наследника (дочерний). Применяется в основном только к методам и довольно редко, нужно основание. Чаще всего используется для наследования;
  
        class Parent {
          protected void show() {
              System.out.println("Protected method");
          }
        }
        
        class Child extends Parent {
          void display() {
              show(); // доступно через наследование
          }
        }
Для чего же следует использовать модификаторы доступа? При разработке ООП-кода классы проектируются с целью моделирования сущностей предметной области. Описывая класс разработчик выделяет внешнюю и внутреннюю реализации типа. Модификаторы доступа позволяют при проектировании класса указать что есть интерфейс (внешняя реализация) и открыть ее для использования, а что есть внутренняя реализация.

Применение модификаторов:
- Классы могут быть только public или default (вложенные классы могут быть private или protected).
- Поля, методы и конструкторы могут иметь любой модификатор.
- Лучшая практика – ограничивать доступ по принципу “минимально необходимый уровень”, чаще всего используя private и protected для инкапсуляции.


### 7. Расскажите про конструкторы, с какими модификаторами они применяются, могут ли они наследоваться \ переопреляться ?
Конструктор – это специальный метод, имя конструктора совпадает с именем класса, конструктор не имеет возвращаемого значения. Он инициализирует поля и устанавливает начальное состояние объекта. Конструкторов в классе может быть сколько угодно, различаться они должны количеством и/или типом параметров (это называется перегрузка конструкторов). Вызываться конструктор может только при создании объекта после оператора new.
“Зачем нужен конструктор?”, можно сказать: для того, чтобы объекты всегда находились в правильном состоянии. Когда ты используешь конструкторы, все твои переменные будут корректно проинициализированы, и в программе не будет машин со скоростью 0 и прочих “неправильных” объектов.

    class Example {
        private Example() {
        System.out.println("Private constructor");
    }

    public static Example getInstance() {
        return new Example(); // можно создавать объект внутри класса
        }
    }
Если ты будешь инициализировать поля самостоятельно, велик риск что-нибудь пропустить и ошибиться. А с конструктором такого не будет: если ты передал в него не все требуемые аргументы или перепутал их типы, компилятор сразу же выдаст ошибку.
Отдельно стоит сказать о том, что внутрь конструктора не стоит помещать логику твоей программы. Для этого в твоем распоряжении есть методы, в которых ты можешь описать весь

Рассмотрим все особенности конструктора.
- Конструктор – это метод, имя которого совпадает с именем класса.
- Конструктор не имеет типа возвращаемого значения.
- При объявлении конструктора можно использовать любой их четырех модификаторов доступа.
- Количество конструкторов в классе не ограничено так как конструкторы можно перегружать (т.е. создавать конструкторы с различным количеством и/или типом параметров).
- С помощью ключевого слова this([параметры]) можно вызвать один конструктор из конструктора как обыкновенный метод. Этот оператор используется только в первой строке конструктора (до него в теле конструктора могут быть только комментарии).
- Конструкторы применяются для начальной инициализации полей создаваемого объекта. Реализовывать какую-либо логику в коде конструктора считается плохи стилем программирвоания.
- Конструкторы не наследуются.
- Не бывает классов без конструкторов. Если в классе явно не определить ни одного конструктора, тогда компилятор добавляет конструктор по умолчанию – это конструктор без параметров, с пустым телом, и с таким же атрибутом доступа, как и у класса.
- Если же в классе определить хоть один конструктор, то конструктор по умолчанию добавлен не будет. При необходимости же создавать объекты, не передавая в конструктор параметры, подходящий конструктор придется также определить явно.
- Какие именно конструкторы нужно определить в классе и сколько их должно быть определяет разработчик (правила языка программирования этого определить не могут). Необходимо проанализировать предметную область и определить все возможные варианты создания объекта, которые могут понадобиться в дальнейшем
- static конструкторов в java нет;
- Используется для синглтонов (Singleton) или статических фабрик (Factory Method).

Краткий ответ на собеседовании:
Конструктор – это специальный метод, вызываемый при создании объекта. Он не наследуется и не переопределяется, потому что конструкторы не являются обычными методами и не участвуют в полиморфизме, но может быть вызван через super(). Конструкторы могут быть public, protected, default и private. Также в Java возможна перегрузка конструкторов (overloading).

### 8. Можно ли в классе заимплементить 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?
Да, в Java класс может реализовывать несколько интерфейсов с помощью ключевого слова implements.

    interface A {
        void doSmth();
    }
    
    interface B {
        void doSmth();
    }
    
    class MyClass implements A, B {
        @Override
        public void doSmth() {
            System.out.println("Implemented doSmth()");
        }
    }
Ответ: Код компилируется без ошибок, и метод doSmth() должен быть реализован один раз в MyClass, так как интерфейсы не содержат реализацию методов.

А если в интерфейсах есть default-методы?
Если оба интерфейса имеют default-метод с одинаковой сигнатурой, то при компиляции возникнет конфликт. Java не знает, какой именно метод использовать, и потребует явного разрешения конфликта.

    interface A {
        default void doSmth() {
            System.out.println("A's default doSmth");
        }
    }
    interface B {
        default void doSmth() {
            System.out.println("B's default doSmth");
        }
    }
    class MyClass implements A, B {
        @Override
        public void doSmth() {
            // Разрешаем конфликт явно
            B.super.doSmth(); // Или A.super.doSmth();
        }
    }
Ответ: Если в интерфейсах A и B есть default-методы с одинаковой сигнатурой, то класс обязан переопределить метод и явно указать, чей метод он использует (A.super.doSmth(); или B.super.doSmth();).

Краткий ответ на собеседовании:
Да, класс может реализовывать несколько интерфейсов. Если в интерфейсах объявлен один и тот же метод без реализации, он просто реализуется один раз в классе. Если же в интерфейсах есть default-методы с одинаковыми сигнатурами, Java требует явного разрешения конфликта через A.super.methodName() или B.super.methodName().


[← Вернуться к вопросам](README.md)