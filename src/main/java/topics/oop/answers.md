### 6. Расскажите про модификаторы доступа, к чему они применяются.
Модификаторы — это специальные слова языка Java, которые вы можете использовать для изменения элементов (классов, методов, переменных). В Java есть две категории модификаторов: модификаторы доступа и другие модификаторы.
Модификаторы доступа определяют область видимости и доступность классов, методов, полей и конструкторов. В Java есть четыре уровня доступа:
* public - открытый элемент. Доступ к нему можно получить из класса, снаружи класса, внутри и снаружи пакета, в пределах одного проекта (Java файл может иметь только один public класс и множество подклассов). Используется, если класс или его члены должны быть доступны в любой точке программы;

        public class Example {
            public int value;
        
            public void show() {
                System.out.println("Public method");
            }
        }

* private — доступ только внутри того же класса. Применяется для инкапсуляции данных, чтобы ограничить прямой доступ к полям и методам;

        class Example {
          private int value; // доступен только внутри Example
        
          private void show() {
              System.out.println("Private method");
          }
        }
* default — элементу с модификатором по умолчанию, есть доступ только внутри пакета. Устанавливается ко всем полям и методам, в которых не подставлены другие модификаторы. Применяется, когда нет необходимости предоставлять доступ извне пакета;

        class Example {
           int value; // доступен внутри пакета
        }
* protected — можно получить доступ внутри и снаружи пакета через дочерний класс и только в классе наследника (дочерний). Применяется в основном только к методам и довольно редко, нужно основание. Чаще всего используется для наследования;
  
        class Parent {
          protected void show() {
              System.out.println("Protected method");
          }
        }
        
        class Child extends Parent {
          void display() {
              show(); // доступно через наследование
          }
        }
Для чего же следует использовать модификаторы доступа? При разработке ООП-кода классы проектируются с целью моделирования сущностей предметной области. Описывая класс разработчик выделяет внешнюю и внутреннюю реализации типа. Модификаторы доступа позволяют при проектировании класса указать что есть интерфейс (внешняя реализация) и открыть ее для использования, а что есть внутренняя реализация.

Применение модификаторов:
- Классы могут быть только public или default (вложенные классы могут быть private или protected).
- Поля, методы и конструкторы могут иметь любой модификатор.
- Лучшая практика – ограничивать доступ по принципу “минимально необходимый уровень”, чаще всего используя private и protected для инкапсуляции.


### 7. Расскажите про конструкторы, с какими модификаторами они применяются, могут ли они наследоваться \ переопреляться ?
Конструктор – это специальный метод, имя конструктора совпадает с именем класса, конструктор не имеет возвращаемого значения. Он инициализирует поля и устанавливает начальное состояние объекта. Конструкторов в классе может быть сколько угодно, различаться они должны количеством и/или типом параметров (это называется перегрузка конструкторов). Вызываться конструктор может только при создании объекта после оператора new.
“Зачем нужен конструктор?”, можно сказать: для того, чтобы объекты всегда находились в правильном состоянии. Когда ты используешь конструкторы, все твои переменные будут корректно проинициализированы, и в программе не будет машин со скоростью 0 и прочих “неправильных” объектов.

    class Example {
        private Example() {
        System.out.println("Private constructor");
    }

    public static Example getInstance() {
        return new Example(); // можно создавать объект внутри класса
        }
    }
Если ты будешь инициализировать поля самостоятельно, велик риск что-нибудь пропустить и ошибиться. А с конструктором такого не будет: если ты передал в него не все требуемые аргументы или перепутал их типы, компилятор сразу же выдаст ошибку.
Отдельно стоит сказать о том, что внутрь конструктора не стоит помещать логику твоей программы. Для этого в твоем распоряжении есть методы, в которых ты можешь описать весь

Рассмотрим все особенности конструктора.
- Конструктор – это метод, имя которого совпадает с именем класса.
- Конструктор не имеет типа возвращаемого значения.
- При объявлении конструктора можно использовать любой их четырех модификаторов доступа.
- Количество конструкторов в классе не ограничено так как конструкторы можно перегружать (т.е. создавать конструкторы с различным количеством и/или типом параметров).
- С помощью ключевого слова this([параметры]) можно вызвать один конструктор из конструктора как обыкновенный метод. Этот оператор используется только в первой строке конструктора (до него в теле конструктора могут быть только комментарии).
- Конструкторы применяются для начальной инициализации полей создаваемого объекта. Реализовывать какую-либо логику в коде конструктора считается плохи стилем программирвоания.
- Конструкторы не наследуются.
- Не бывает классов без конструкторов. Если в классе явно не определить ни одного конструктора, тогда компилятор добавляет конструктор по умолчанию – это конструктор без параметров, с пустым телом, и с таким же атрибутом доступа, как и у класса.
- Если же в классе определить хоть один конструктор, то конструктор по умолчанию добавлен не будет. При необходимости же создавать объекты, не передавая в конструктор параметры, подходящий конструктор придется также определить явно.
- Какие именно конструкторы нужно определить в классе и сколько их должно быть определяет разработчик (правила языка программирования этого определить не могут). Необходимо проанализировать предметную область и определить все возможные варианты создания объекта, которые могут понадобиться в дальнейшем
- static конструкторов в java нет;
- Используется для синглтонов (Singleton) или статических фабрик (Factory Method).

Краткий ответ на собеседовании:
Конструктор – это специальный метод, вызываемый при создании объекта. Он не наследуется и не переопределяется, потому что конструкторы не являются обычными методами и не участвуют в полиморфизме, но может быть вызван через super(). Конструкторы могут быть public, protected, default и private. Также в Java возможна перегрузка конструкторов (overloading).

### 8. Можно ли в классе заимплементить 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?
Да, в Java класс может реализовывать несколько интерфейсов с помощью ключевого слова implements.

    interface A {
        void doSmth();
    }
    
    interface B {
        void doSmth();
    }
    
    class MyClass implements A, B {
        @Override
        public void doSmth() {
            System.out.println("Implemented doSmth()");
        }
    }
Ответ: Код компилируется без ошибок, и метод doSmth() должен быть реализован один раз в MyClass, так как интерфейсы не содержат реализацию методов.

А если в интерфейсах есть default-методы?
Если оба интерфейса имеют default-метод с одинаковой сигнатурой, то при компиляции возникнет конфликт. Java не знает, какой именно метод использовать, и потребует явного разрешения конфликта.

    interface A {
        default void doSmth() {
            System.out.println("A's default doSmth");
        }
    }
    interface B {
        default void doSmth() {
            System.out.println("B's default doSmth");
        }
    }
    class MyClass implements A, B {
        @Override
        public void doSmth() {
            // Разрешаем конфликт явно
            B.super.doSmth(); // Или A.super.doSmth();
        }
    }
Ответ: Если в интерфейсах A и B есть default-методы с одинаковой сигнатурой, то класс обязан переопределить метод и явно указать, чей метод он использует (A.super.doSmth(); или B.super.doSmth();).

Краткий ответ на собеседовании:
Да, класс может реализовывать несколько интерфейсов. Если в интерфейсах объявлен один и тот же метод без реализации, он просто реализуется один раз в классе. Если же в интерфейсах есть default-методы с одинаковыми сигнатурами, Java требует явного разрешения конфликта через A.super.methodName() или B.super.methodName().
### 15. Расскажите про класс String, пул строк.
Для работы со строками в Java определен класс String. Для сложения двух строк можно воспользоваться оператором +.
Преобразование объектов других классов к строковому представлению выполняется через неявный вызов метода `toString()` у объекта.

Имеется возможность перевод числа в строке в числовой тип. Для перевода необходимо использовать соответствующий класс-обёртку.
Все эти методы начинаются со слова parse:
```java
Integer i = Integer.parseInt("4"); 
Double d = Double.parseDouble("23.34D");
```
Основные особенности класса:
1. Неизменяемость (Immutable) - После создания строку нельзя изменить. Любые операции (например, `concat()`, `replace()`)
   возвращают новый объект строки.
2. Для сравнения содержимого строк используется `equals()`, а не "=="
3. Создание строк может быть выполнено несколькими способами:
   1. Через конструктор - Объект создается в heap'е: `String str1 = new String("Hello")`
   2. Через литерал - Объект создаётся в String Pool'е: `String str2 = "Hello"`

**String Pool** - специальная область в heap'е, где хранятся уникальные строковые литералы с целью
экономия памяти за счет повторного использования одинаковых строк.
При создании строки через литерал (`String str2 = "Hello"`), JVM проверяет наличие такой строки в пуле.
- Если есть — возвращает ссылку на существующий объект.
- Если нет — создает новый объект в пуле.

Строки, созданные через new String(), не попадают в пул автоматически, но благодаря методу `intern()` можно вручную
добавить данную строку в пул.

### 16. Расскажите про варианты использования зарезервированных слов таких как super, this, class, instance of.
1. super - ссылается на родительский класс (суперкласс). Используется для вызова конструктора родительского класса, методов, полей:
```java
public class Animal {
    public Animal(String name) {
        System.out.println("Animal: " + name);
    }
    public makeSound(){}
}

public class Dog extends Animal {
    public Dog() {
        super("Toto"); // Вызов конструктора Animal
        super.makesound(); //Вызов метода родительского класса
    }
}
```
2. this - ссылка на текущий экземпляр объекта. Используется для разрешения конфликта между полями класса и метода,
   вызова конструкта, передачи объекта в методе. Примеры использования:
```java
public class Person {
    private String name;

    public Person(String name) { 
        this.name = name; // this указывает на поле класса
    }
    public Person(){
        this("John"); // Вызов конструктора с параметром
    }
    public void show(){
        System.out.println(this); // Вызов toString() текущего объекта
    }
}
```
3. class - предоставляет метаданные о классе. Часто используется в рефлексии.
```java
if (listEx.getClass() == ArrayList.class) { // Проверка на принадлежность объекта listEx к классу ArrayList
        System.out.println("Это ArrayList");
}
```
4. instance of - проверяет, является ли объект экземпляром указанного класса или интерфейса. Часто используется при работе
   с полиморфизмом.
```java
Object obj = "Hello";
if (obj instanceof String) { // Проверка obj на принадлежность к классу String
    //Блок кода
}
```
### 17. java массивы, к какому типу относится, какие есть особенности можно ли создать 0 длинны, могут ли расширяться.
Массив в Java - это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор
пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку).
Доступ к конкретной ячейке осуществляется через её индекс. Элементы нумеруются с нуля. Массивы в Java являются объектами,
даже если хранят примитивные типы. Java поддерживает создание многомерных(2,3 и т.д) массивов.
Пример объявления массива, в котором может храниться 10 целых чисел:

`int[] myArray = new int[10];`

Также можно объявлять массивы с уже занесёнными значениями:

`int[] myArray2 = {1, 2, 3, 4, 5}`

Двумерный массив выглядит следующим образом:

`int[][] myArray3 = new int [3][3];`

Имеется встроенная поддержка сортировки и поиска содержимого массива: ` Arrays.sort()` и `Arrays.binarySearch()` соответственно

Особенности:
- **Быстрый доступ к данным**: элементы доступны за O(1) благодаря использованию индексов через array[index].
- **В Java можно создать массив нулевой длины**:
```java
int[] emptyIntArray = new int[0];
String[] emptyStringsArray = {}; // При возврате значения будет показан пустой результат вместо null
```
- **Размер массива фиксирован после создания**. Для решения данной проблемы можно воспользоваться
  ArrayList из Java Collections, который имеет возможность динамически расширяться.

[← Вернуться к вопросам](README.md)